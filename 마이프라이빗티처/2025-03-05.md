# Nest.js 네이밍 컨벤션
✅ **코드는 카멜 케이스 유지 (`startDate`)**

- TypeScript에서는 `camelCase`가 일반적인 네이밍 스타일이야.
- 대부분의 JavaScript/TypeScript 코드 스타일 가이드(Airbnb, Google 등)도 `camelCase`를 권장해.
- NestJS, TypeORM 공식 문서도 엔티티에서는 `camelCase`를 사용해.

✅ **DB는 스네이크 케이스 유지 (`start_date`)**

- 데이터베이스에서는 **스네이크 케이스(snake_case)**가 더 일반적이야.
- SQL에서는 `start_date`처럼 구분하는 게 가독성이 더 좋아.
- PostgreSQL, MySQL 같은 DB에서도 일반적으로 `snake_case`를 많이 사용해.

# [[GIT]] 새로 만든 레파지토리에 기존 디렉토리 옮기는 중 에러

```
git remote add origin https://github.com/GraceNcompany/Planner.git
git branch -M main
git push -u origin main
```

```
error: src refspec main does not match any
error: 레퍼런스를 'https://github.com/GraceNcompany/Planner.git'에 푸시하는데 실패했습니다
```


# [[GIT]] git branch -M 

### 📌 `git branch -M` 명령어의 의미

```bash
git branch -M <브랜치이름>
```

- **현재 브랜치를 `<브랜치이름>`으로 변경하거나, 브랜치를 강제(rename)로 변경하는 명령어**야.
- `-M` 옵션을 사용하면 기존 브랜치가 존재하더라도 강제로 이름을 변경할 수 있어.

---

### 🔹 `git branch -M main` 이 하는 일

```bash
git branch -M main
```

- 현재 브랜치의 이름을 **`main`으로 변경**
- 기존에 `main` 브랜치가 있더라도 강제로 덮어씌움

💡 **즉, 로컬에서 `master`(기본 브랜치)로 되어 있다면 `main`으로 바꾸는 역할**을 해.

---

### 🔹 `-m` vs. `-M` 차이

|옵션|설명|
|---|---|
|`-m`|브랜치 이름 변경 (단, 같은 이름의 브랜치가 있으면 에러 발생)|
|`-M`|브랜치 이름 강제 변경 (기존 브랜치가 있어도 덮어쓰기)|

✅ **예제**

```bash
git branch -m old_branch new_branch  # old_branch → new_branch로 변경
git branch -M new_branch             # 현재 브랜치를 new_branch로 강제 변경
```

---

### 🚀 `git branch -M main`을 왜 쓰는가?

기본적으로 Git의 초기 브랜치 이름은 `master`였지만, 최근에는 `main`을 기본 브랜치로 변경하는 경우가 많아.  
그래서 기존 프로젝트에서 `master`를 `main`으로 바꿀 때 `git branch -M main`을 자주 사용해.

---

### 🎯 결론

**`git branch -M main` → 현재 브랜치를 `main`으로 강제 변경하는 명령어**  
보통 `git init` 후 첫 커밋을 만들고 원격 저장소에 푸시하기 전에 사용해! 🚀

# [[GIT]] -u 옵션 (--set-upstream)

### 📌 `-u` 옵션 (`--set-upstream`)의 의미

```bash
git push -u origin main
```

여기서 `-u`는 **`--set-upstream`의 줄임말**이야.  
이 옵션을 사용하면 **현재 브랜치를 원격 브랜치와 연결(upstream tracking)시켜 줘.**

---

### 🔹 `git push -u origin main`이 하는 일

1. 로컬 브랜치 `main`을 원격 저장소(`origin`)에 푸시
2. **로컬 브랜치 `main`을 원격 브랜치 `origin/main`과 연결 (tracking branch 설정)**
3. 다음부터 `git push` 또는 `git pull`을 할 때, **원격 브랜치를 자동으로 인식**해서 실행 가능

✅ 즉, 한 번 `-u`를 사용해 `upstream`을 설정하면, 이후에는 그냥 `git push` 또는 `git pull`만 입력하면 됨.

---

### 🔹 `-u` 없이 `git push` 하면?

처음 `git push origin main`을 할 때 `-u` 옵션 없이 실행하면, 아래와 같은 메시지가 나올 수도 있어.

```bash
fatal: The current branch main has no upstream branch.
```

이 경우, **매번 원격 브랜치를 명시적으로 입력해야 함** (`git push origin main`).

---

### 🎯 `-u`의 장점: 이후에는 `git push`만 입력하면 됨

```bash
git push -u origin main  # 최초 push (upstream 설정)
git push                 # 이후부터는 이 명령어만으로 push 가능!
git pull                 # pull도 원격에서 자동으로 가져옴
```

---

### 🚀 결론: `-u`는 upstream 브랜치를 설정하는 옵션!

- **한 번 `-u`를 사용하면 이후 push/pull에서 브랜치를 명시할 필요가 없음**
- `git push -u origin main` → `main` 브랜치를 `origin/main`과 연결
- 다음부터 `git push`, `git pull`만 입력하면 동기화됨! 🚀


# [[Nest.js]] @Column의 type 

### 📌 `@Column({ type: 'timestamp' })` vs `startDate: Date;`

💡 **"데이터베이스에 저장될 타입"과 "TypeScript에서 사용할 타입"이 다르기 때문!**

---

## 🛠️ **코드 분석**

```typescript
@Column({ type: 'timestamp', nullable: true })
startDate: Date;
```

여기서 **두 가지 타입을 정의**하고 있어:

1. **데이터베이스 타입 (`type: 'timestamp'`)**  
    → `type` 옵션을 통해 **DB에서 'timestamp' 타입으로 저장됨**  
    → 즉, **"이 값은 날짜/시간으로 저장될 거야"** 라고 TypeORM에게 알려주는 것
    
2. **TypeScript 타입 (`startDate: Date;`)**  
    → NestJS 코드에서 사용할 때 **TypeScript에서는 `Date` 타입으로 다룸**  
    → 즉, `startDate.getFullYear()` 같은 **날짜 관련 메서드를 사용할 수 있음**
    

---

## 📌 **비유해서 쉽게 이해하기**

🍔 **"햄버거 주문하기" 비유 🍔**

- 데이터베이스는 "햄버거 가게"야.
- TypeScript는 "손님(프론트엔드 개발자)"이야.
- `type: 'timestamp'`은 **햄버거를 어떻게 만들지(DB 저장 형식)**를 정하는 것.
- `startDate: Date;`는 **손님(개발자)이 햄버거를 어떻게 먹을지(사용할 데이터 타입)**를 정하는 것.

즉,  
**"DB에서는 'timestamp'로 저장하지만, NestJS에서는 `Date` 객체로 다룰 거야!"** 라고 설정하는 것!

---

## 📊 **데이터베이스에 저장되는 값 예시**

```sql
-- '2025-03-04 12:34:56' 같은 형태로 저장됨
start_date TIMESTAMP NULL DEFAULT NULL
```

NestJS에서 `Date` 타입을 사용하면 `startDate.toISOString()` 같은 메서드를 쉽게 쓸 수 있음.

---

## 🔥 **정리**

✅ `type: 'timestamp'` → **DB에서 "타임스탬프" 형식으로 저장**  
✅ `startDate: Date;` → **NestJS(TypeScript)에서 "날짜 객체"로 사용**  
✅ **DB 저장 타입과 코드에서 다루는 타입을 구분하는 것!** 🎯

# 언제 @Column에 type을 붙여야 할까?

### 📌 `@Column({ length: 200, nullable: true })`에서 `type`을 명시하지 않는 이유

💡 **기본값이 자동으로 설정되기 때문!**

---

### 🛠️ **코드 분석**

```typescript
@Column({ length: 200, nullable: true })
title: string;
```

여기서는 **`type`을 명시하지 않았음에도 작동**하는데, 그 이유는 **TypeORM이 `title: string;`을 보고 자동으로 타입을 결정**하기 때문이야.

#### ✅ **TypeORM이 자동으로 판단하는 방식**

- **`title: string;` → 기본적으로 `VARCHAR`(문자열) 타입이 됨**
- `length: 200`을 추가했기 때문에 `VARCHAR(200)`으로 변환됨.
- `nullable: true`를 추가했으므로, 값이 없어도 허용됨.

### 📊 **데이터베이스에 저장되는 값 예시**

```sql
title VARCHAR(200) NULL;
```

---

## 🔥 **그럼 `type`을 명시해야 하는 경우는?**

타입이 **자동으로 인식되지 않는 경우**에는 명시해야 해. 예를 들어:

### **1️⃣ 날짜/시간 타입**

```typescript
@Column({ type: 'timestamp', nullable: true })
startDate: Date;
```

👉 `Date` 타입은 여러 DB 타입(`DATE`, `DATETIME`, `TIMESTAMP`)이 가능하기 때문에 **명확하게 `type`을 지정해야 함**.

---

### **2️⃣ 숫자 타입**

```typescript
@Column({ type: 'float' })
price: number;
```

👉 `number` 타입은 여러 DB 타입(`INTEGER`, `FLOAT`, `DECIMAL` 등)이 될 수 있어서 **명시적으로 `float`을 지정**해야 함.

---

### **3️⃣ JSON 같은 복잡한 타입**

```typescript
@Column({ type: 'json', nullable: true })
metadata: object;
```

👉 `object` 타입은 DB에서 자동으로 변환할 수 없기 때문에 **명확히 `json` 타입을 지정**해야 함.

---

## 🎯 **결론**

✔ **`string`은 TypeORM이 자동으로 `VARCHAR`로 인식하므로 `type`을 명시하지 않아도 됨**  
✔ **자동으로 변환되지 않는 타입(Date, Number, JSON 등)은 `type`을 명시해야 함**  
✔ **자동 인식이 가능하지만, DB 스키마를 명확하게 하고 싶다면 `type`을 직접 명시하는 것도 가능!**

✅ **즉, `type`을 생략해도 자동으로 `VARCHAR`가 되기 때문에 `string`에는 따로 안 붙이는 것!** 🚀

# DATETIME 과 TIMESTAMP
### 📌 **`DATETIME` vs `TIMESTAMP` 타임존 차이 쉽게 이해하기**

#### ⚡ **핵심 차이점:**

- `DATETIME` **👉 저장할 때 그대로 저장됨 (타임존 고려 X)**
- `TIMESTAMP` **👉 UTC(세계 표준시)로 변환 후 저장됨** (조회 시 타임존 변환 가능)

---

### 🛠 **1. `DATETIME` → 그냥 입력한 그대로 저장됨**

- 타임존과 **상관없이** 입력된 값이 그대로 DB에 저장됨.
- 조회할 때도 **입력한 그대로** 나옴.

✅ 예제 (`DATETIME`)

```sql
CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    order_time DATETIME
);
```

```sql
INSERT INTO orders (order_time) VALUES ('2025-03-04 15:30:00');
```

📌 **DB에 그대로 저장됨 (타임존 변환 X)**

|id|order_time|
|---|---|
|1|2025-03-04 15:30:00|

✅ **서울(KST, UTC+9)에서 조회**

```sql
SELECT order_time FROM orders;
```

📌 결과: `2025-03-04 15:30:00` (그대로!)

✅ **뉴욕(EST, UTC-5)에서 조회**

```sql
SELECT order_time FROM orders;
```

📌 결과: `2025-03-04 15:30:00` (그대로!)

---

### 🛠 **2. `TIMESTAMP` → UTC(세계 표준시)로 변환되어 저장됨**

- 입력할 때 **UTC(세계 표준시)** 기준으로 변환돼서 저장됨.
- 조회할 때 사용자의 타임존에 맞게 변환할 수 있음.

✅ 예제 (`TIMESTAMP`)

```sql
CREATE TABLE logs (
    id INT AUTO_INCREMENT PRIMARY KEY,
    created_at TIMESTAMP
);
```

```sql
INSERT INTO logs (created_at) VALUES ('2025-03-04 15:30:00');
```

📌 **DB에는 UTC 기준으로 변환되어 저장됨**  
(한국 `KST`는 `UTC+9`이므로 `9시간 빼기` 적용됨)

|id|created_at (UTC로 변환)|
|---|---|
|1|2025-03-04 06:30:00 UTC|

✅ **서울(KST, UTC+9)에서 조회**

```sql
SELECT created_at FROM logs;
```

📌 결과: `2025-03-04 15:30:00` **(자동 변환됨!)**

✅ **뉴욕(EST, UTC-5)에서 조회**

```sql
SELECT created_at FROM logs;
```

📌 결과: `2025-03-04 01:30:00` **(자동 변환됨!)**

---

### 🚀 **정리: 언제 어떤 걸 써야 할까?**

|타입|저장 방식|타임존 변환|자동 `CURRENT_TIMESTAMP`|
|---|---|---|---|
|`DATETIME`|입력된 그대로 저장|❌ (타임존 무시)|❌|
|`TIMESTAMP`|UTC로 변환 후 저장|✅ (조회 시 변환)|✅|

✅ **언제 `DATETIME`을 써야 할까?**

- "2025-03-04 15:30:00" 같은 값을 **그대로 저장**하고 싶을 때
- 타임존 변환이 필요 없는 경우 (예: 생일, 예약 날짜)

✅ **언제 `TIMESTAMP`을 써야 할까?**

- **전 세계에서 같은 시간 기준을 유지해야 할 때**
- **로그 기록**, **데이터 생성/수정 시간 저장**
- `CURRENT_TIMESTAMP`로 자동으로 현재 시간을 저장할 때

📌 **🌟 만약 전 세계 사용자(다른 타임존)를 고려해야 한다면 `TIMESTAMP`를 쓰는 게 좋다!**


