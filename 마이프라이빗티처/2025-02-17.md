Beautiful DND 강의
https://egghead.io/lessons/react-reorder-columns-with-react-beautiful-dnd

# UUID(Universally Unique Identifier)
```javascript
import { v4 as uuidv4 } from "uuid";
```

이 코드는 `uuid` 라이브러리에서 **버전 4(UUID v4)**를 생성하는 `uuidv4` 함수를 가져오는 역할을 합니다.

### 역할:

`uuidv4()`를 호출하면 **랜덤한 UUID(Universally Unique Identifier)**를 생성합니다.

### 예제:

```javascript
import { v4 as uuidv4 } from "uuid";

const uniqueId = uuidv4();
console.log(uniqueId); // "f47ac10b-58cc-4372-a567-0e02b2c3d479" (랜덤 값)
```

### 사용 이유:

- **고유한 ID 생성** (ex: 데이터베이스의 키, 트랜잭션 ID, 파일 이름 등)
- **중복 방지** (랜덤하게 생성되므로 중복될 확률이 극히 낮음)

### 설치 방법:

`uuid` 패키지가 없다면 아래 명령어로 설치 가능:

```sh
npm install uuid
```

💡 `uuidv4()`는 순전히 **랜덤**한 값을 생성하며, 시간이나 특정 규칙을 따르지 않음.

# 리액트 컴포넌트 설계 

💡 **UI는 같지만 기능이 다르면?**

같은 UI이지만 기능이 다르면 **세 가지 방법 중 하나를 선택**하면 돼:

---

### ✅ **방법 1: 하나의 공통 컴포넌트 + `props`로 기능 분기 (추천)**

> 📌 **적용 조건**

- UI가 완전히 동일하고 기능 차이가 크지 않다면 `props`를 활용해서 **기능을 컨트롤**
- 예를 들어, `Navbar.tsx`에서 `admin`과 `app`에서 보여줄 메뉴나 동작을 다르게 하려면 `role` 같은 props를 넘겨서 분기 가능

**예시 (`src/components/Navbar.tsx`)**

```tsx
interface NavbarProps {
  role: "admin" | "user";
}

const Navbar: React.FC<NavbarProps> = ({ role }) => {
  return (
    <nav>
      <ul>
        <li>Home</li>
        <li>About</li>
        {role === "admin" ? <li>Admin Dashboard</li> : <li>My Profile</li>}
      </ul>
    </nav>
  );
};

export default Navbar;
```

📌 **각 그룹에서 사용할 때**

```tsx
// admin에서 사용
<Navbar role="admin" />

// app에서 사용
<Navbar role="user" />
```

✅ **장점:** 중복 코드가 없고, 유지보수하기 쉬움  
⚠️ **단점:** 기능 차이가 너무 많으면 `props`로 분기하는 게 복잡해질 수 있음

---

### ✅ **방법 2: `HOC` (Higher-Order Component) 패턴 사용**

> 📌 **적용 조건**

- UI는 같지만, `admin`과 `app`에서 특정 로직(예: 인증 방식, API 호출)이 다를 때

**예시 (`withRole.tsx`)**

```tsx
const withRole = (Component: React.FC<NavbarProps>, role: "admin" | "user") => {
  return (props: any) => {
    // role에 따라 추가 기능 (예: 관리자 페이지 접근 제한)
    if (role === "admin" && !isAdmin()) {
      return <p>Access Denied</p>;
    }

    return <Component {...props} role={role} />;
  };
};

const AdminNavbar = withRole(Navbar, "admin");
const UserNavbar = withRole(Navbar, "user");
```

📌 **사용 예시**

```tsx
<AdminNavbar />
<UserNavbar />
```

✅ **장점:** `props`가 많아질 경우 가독성이 좋음  
⚠️ **단점:** 코드가 조금 복잡해질 수 있음

---

### ✅ **방법 3: 아예 `admin/Navbar.tsx`, `app/Navbar.tsx` 따로 관리**

> 📌 **적용 조건**

- **공통 UI는 유지하지만, 로직 차이가 너무 많아지면 분리하는 게 나음**
- `Navbar.tsx` 내부에서 `role`에 따라 `if` 문이 많아지거나, `useEffect` 로직이 다르면 **별도 컴포넌트**로 관리하는 게 유지보수하기 좋음.

```
src
 ├── components
 │   ├── NavbarBase.tsx  // 공통 UI 컴포넌트
 │
 ├── admin
 │   ├── Navbar.tsx  // admin 전용 기능 포함
 │
 ├── app
 │   ├── Navbar.tsx  // app 전용 기능 포함
```

📌 **예시 (`admin/Navbar.tsx`)**

```tsx
import NavbarBase from "@/components/NavbarBase";

const AdminNavbar = () => {
  return <NavbarBase role="admin" />;
};
```

📌 **예시 (`app/Navbar.tsx`)**

```tsx
import NavbarBase from "@/components/NavbarBase";

const UserNavbar = () => {
  return <NavbarBase role="user" />;
};
```

✅ **장점:** `admin`과 `app`의 기능이 너무 달라지면 유지보수 편리  
⚠️ **단점:** 중복 코드가 생길 가능성이 있음

---

### 💡 **결론**

- **기능 차이가 크지 않다면?** → `props`로 컨트롤 (**방법 1**)
- **추가 기능이 많다면?** → `HOC` 패턴 사용 (**방법 2**)
- **로직이 너무 다르면?** → `admin`, `app` 각각 컴포넌트 관리 (**방법 3**)

👀 **기능 차이가 크지 않다면 "방법 1"로 유지하는 게 가장 효율적이야!** 🚀

# Dynamic Import 란

